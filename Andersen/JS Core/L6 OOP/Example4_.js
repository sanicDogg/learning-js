// 3.1 шаг пути ООП - Constructor Functions

// Функция-конструктор - это функция, которая была вызвана с помощью оператора new.

// Функция-конструктор - конструирует объект, наполняя его содержимым и создаёт объект-прототип 
// для этого объекта равным Функция-конструктор.protopype

// this внутри функции-конструктора, вызванной через new, указывает на только что созданный объект.

// Существует договорённость - называть функции конструкторы с заглавной буквы, чтобы было понятно,
// что данную функцию нужно вызывать через new, и эта функция является функцией-конструктором.

// Built-in функции констукторы: Object(), String(), Number(), Boolean(), Function(), Date(), ...

function Elf(name, weapon) {
    // создаётся {}
    // {}.__proto__ --> Elf.prototype
    // this --> {}

    this.name = name;
    this.weapon = weapon;

    // return this неявно
}

Elf.prototype.attack = function() {
    console.log(`${this.name} attacks with ${this.weapon}`); 
}

// const elfPeter = Elf("Peter", "bow"); // такой вызов опасен не в use strict - кто скажет, чем?

const elfSam = new Elf("Sam", "sword"); // а тут всё верно

// Объект, ссылка на который хранится в Elf.prototype - будет служить объектом-прототипом для всех
// создаваемых объектов с помощью функции-конструктора Elf

// Это значит, что все методы, которые мы хотим разделить (расшарить) между порождаемыми объектами,
// мы можем положить в Функция-конструктор.prototype, и они будут созданы только один раз (экономия памяти)


// ***
// В JS комьюнити многие считали, что написание кода через функции-конструкторы выглядит достаточно громоздко.
// Но функции-конструкторы, свойство prototype, прототипная модель наследования - это ядро природы JS.

// Как сейчас решается проблема такого грамоздкого и не совсем понятного кода?

// К нам на помощь пришёл синтаксический сахар, который позволяет обернуть данные и методы в одно целое - Класс.