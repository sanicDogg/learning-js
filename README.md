# learning-js
***Решение задач на JavaScript. Концепты языка JavaScript***

* Папка **codewars** содержит решения интересных задач с сайта codewars.com  
* Папка **js-concepts** содержит 11 файлов с кодом, описывающим концепты JS  
* Папка **yandex** содержит решения задач с Яндекс Контеста  

***

### Концепты JS

**1.	Типы данных в JS**

`null, undefined, boolean, number, string, object, symbol`  

`typeof` позволяет узнать тип переменной

***Неточность:***   
  `typeof null` возвращает `null`  
  `typeof function () {}` вернет `function`  
  `typeof NaN` вернет `number`  


`undefined` используется тогда, когда переменная была создана, но не инициализирована, функции, не возвращающие значения, возвращают `undefined`

**Приведение типов.**

Строковый тип данных приводится к true.
`'', 0, null, undefined, NaN, false` – данные значения приводятся к `false`.
Пустой массив, пустой объект и пустая функция приводятся к `true`.

**Строки и числа.**

При суммировании числа и строки число приводится к строке и результатом сложения будет конкатенация.  
При вычитании строки и числа строка приводится к числу.  
`undefined` + любое число = `NaN`  
== сравнивает два объекта с приведением типов,   
=== сравнивает без приведения типов  
При сравнении `0` и `boolean` `0` приводится к `number`.  
При сравнении `false` с пустым массивом получаем `true`, с пустым объектом `false`  
То же самое происходит при сравнении ‘’  
`0` при сравнении с `null` дает `false`  

**2.	Значения и ссылки**

При копировании в переменную-примитив значение другой переменной все происходит правильно. При копировании массива, например, копируется лишь ссылка на него, то есть обе переменные будут изменяться при изменении значения какой-нибудь ячейки массива.  
Метод `concat()`, вызванный без параметров у любого массива возвращает его копию, а не ссылку на него. В качестве параметров данного метода можно указать добавочные значения ячеек для массива.  
`===` при сравнении двух переменных, ссылающихся на один объект, вернет `true`

**3.	Как работает scope**

Scope – что-то, что говорит нам о доступности определенных переменных в коде.  
Есть глобальный и локальный scope.  
`document` и `window` имеют глобальный scope, так как доступны из любой функции.  

Переменная, объявленная внутри вложенной функции, не будет доступна внутри внешней функции, однако вложенная функция сможет работать с переменными внешней функции.

**4.	Что такое hoisting**

JavaScript при интерпретации какого-либо файла перемещает определение функций в начало файла (мы можем вызывать функции до их объявления)  
Определения переменных также перемещаются в начало файла, но со значениями `undefined`.  
Данное правило работает только с переменными, объявленными через `var`.  
`const` и `let` переменные хойстингу не подвергаются.  
Если мы создаем функцию через переменную (Function Expression), то хойстинг не будет работать.  

**5.	Переменные let и const**

`let` и `const` переменные будут доступны только внутри своего скобочного скоупа.  
Константам, созданным с помощью const, нельзя изменять значения, в противном случае будет `TypeError: Assignment to constant variable.`  
Если константа – это массив, то без всяких ошибок мы можем менять значения элементов массива. То же самое касается объектов.  
У `const` переменных, если это массивы или объекты, мы можем менять только внутренние состояния этих массивов или объектов, в противном случае будет TypeError.  

**6.	Замыкания**

Замыкание – момент, когда функция имеет доступ до переменных из вышестоящего скоупа.  

Одним из примеров использования замыканий является создание «приватных» переменных, недоступных извне, но доступных с помощью методов. Делается это с помощью создания функции, имеющей «приватные» поля. Функция должна вернуть объект с функциями, которые работают с «приватными» полями.  


**7.	Что такое IIFE**

Immediate Invoked Function Expression – функция, которая моментально выполняется.  
Мы можем создавать моментально выполняющиеся функции, их в основном используют для создания локального скоупа.  
Такие функции окружены круглыми скобками.  

**8.	Контекст**

Скоуп указывает на видимость определенных переменных, контекст определяет, как функция была вызвана, постоянно указывает на ключевое слово `this`.  

Мы можем вызвать функцию с определенным контекстом, используя метод `call()`.  
Данный метод нужно написать после названия функции через точку. Первым аргументом функции call должен идти контекст. Контекстом может являться функция, имеющая нужные значения определенных полей.  
`call()` сразу вызывает функцию с нужным контекстом, через запятую после контекста мы можем указать аргументы функции.  

По аналогии с методом `call()` в js есть функция `apply()`, которая вторым аргументом принимает массив аргументов функции.  

Также есть метод `bind()`, который похож на `call()` по аргументам, но он не вызывает функцию сразу, а возвращает ее.  

Стрелочные функции внутри других функций работают в том же контексте, в отличии от обычных вложенных функциях, которые работают в глобальном контексте.  

**9.	Как работает new**

new создает новый экземпляр класса (функции).  
Когда new применяется к какой-либо функции, появляется новый instance данного класса.  
Мы можем создавать функцию, которая будет работать также, как директива new.   
Для это создаем функцию: `function myNew(constructor, ..args) {}`  
Далее в функции нужно создать пустой объект `obj`, затем написать  
`Object.setPrototypeOf(obj, constructor.prototype)`.  
Функция должна вернуть `constructor.apply(obj, args) || obj`  

**10.	Как работают прототипы**

Прототипы используются в двух разных контекстах.  
Каждый объект в js имеет свой прототип, который берется от родительского элемента.  
`__proto__` указывает на прототип родительского объекта.  
У функций мы можем использовать свойство `prototype`, с помощью которого мы можем расширять функционал данного класса (функции). С помощью `prototype` мы классу можем добавлять новые поля и функции.  
`__proto__` работает для объектов, в то время как `prototype` работает для классов.  
По своей работе `__proto__` и `prototype` идентичны.  
Прототипы реализуют механизм наследования.  
С помощью функции `Object.create()` можно создавать объект на базе прототипа, указав этот прототип первым аргументом.  

**11.	Асинхронность**

JavaScript работает в одном потоке.


Node.js 
1.	Парсинг get запроса 
https://youtu.be/qZ5xzkEdkhg?list=PLKaafC45L_SRoYnuEW5cgqHN-kpSTVfMs&t=2734

